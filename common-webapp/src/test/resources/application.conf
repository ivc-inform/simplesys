//spray.can.server {
//  idle-timeout = 7 min
//  request-timeout = 5 min
//}

app {
  port = 9512
  interface = "localhost"

  isomorphicDir = "isomorphic"
  modulesDir = "/client/modules"
  mainServletPath = "/logic/*"

  //modulesDir = "/system/modules"
  //modulesDir = "/system/modules-debug"
  //skin = "Enterprise"

  classPath4Servlet = [
    "$web-inf/classes",
    "$web-inf/lib/common-webapp???version???.jar"
  ]
}

LogActor {
  LogHtmlAndJS = debug
  LogHtml = info
  LogJavaScript = info
}

akka {
  loggers = ["com.simplesys.messages.event.Slf4jLogger"]
  //loggers = ["akka.event.slf4j.Slf4jLogger"]
  //extensions = ["kamon.statsd.StatsD"]
  //loglevel = error
  loglevel = debug
  stdout-loglevel = error
  ask-timeout = 240
  //ask-timeout = 10


  actor {
    debug {
      receive = off
      autoreceive = off
      lifecycle = off
      fsm = off
      unhandled = on
    }

    //    default-dispatcher {
    //parallelism-min = 2

    //      executor = "thread-pool-executor"
    //      max-pool-size-min = 4

    # Throughput for default Dispatcher, set to 1 for as fair as possible
    //      throughput = 2
    //    }

    deployment {
      /messagePreProcessor {
        //dispatcher = pre-processor-dispatcher

        //mailbox = bounded-mailbox

        router = round-robin-pool

        //        resizer {
        //          lower-bound = 1
        //          upper-bound = 2
        //          messages-per-resize = 10
        //        }

        nr-of-instances = 2

        //        dispatcher = processing-core-dispatcher

        pool-dispatcher {
          type = PinnedDispatcher
          executor = "thread-pool-executor"
          throughput = 1
          max-pool-size-min = 2
          max-pool-size-max = 2

        }
      }

      //      /templaterCoordinator {
      //        //        dispatcher = singletons-dispatcher
      //        dispatcher = processing-core-dispatcher
      //      }

      "/stageCoordinator/*" {
        dispatcher = processing-core-dispatcher
      }

      "/packCoordinator/*" {
        dispatcher = processing-core-dispatcher
      }

      "/templaterCoordinator/*" {
        dispatcher = processing-core-dispatcher
      }


      /dictionary {
        dispatcher = processing-core-dispatcher
      }

      /packCoordinator {
        dispatcher = processing-core-dispatcher
      }

      /stageCoordinator {
        dispatcher = processing-core-dispatcher
      }

      //      /messageSampler {
      //        //       dispatcher = singletons-dispatcher
      //        dispatcher = processing-core-dispatcher
      //      }
      //
      //      "/messageSampler/*" {
      //        //       dispatcher = singletons-dispatcher
      //        dispatcher = processing-core-dispatcher
      //      }
      //
      //      /globalScheduler {
      //        //       dispatcher = singletons-dispatcher
      //        dispatcher = processing-core-dispatcher
      //      }


    }

    serializers {
      myKryo = "ru.simplesys.dmprocess.serialization.AkkaKryoSerializer"
      //      kryo = "com.twitter.chill.akka.AkkaSerializer"
      //      java = "akka.serialization.JavaSerializer"
    }

    serialization-bindings {
      "java.io.Serializable" = myKryo

      "akka.persistence.serialization.Snapshot" = myKryo
      //akka-persistence-snapshot
      "akka.persistence.serialization.Message" = myKryo
      //akka-persistence-message
    }
  }

  persistence {
    journal.max-message-batch-size = 1
    //journal.plugin = "bdb-journal"
    # journal.leveldb.native = off
    journal.plugin = "stub-journal"
    //snapshots are good file-based store
    //snapshot-store.plugin = "stub-snapshot-store"
  }

  http {
    log-http-config-on-init = off
    system-name = com-simplesys-http
    timeout = 0
    expired-header-name = wtf
    expired-header-value = wtf2
  }
}

messaging {

  # how often do we send keepalives to the client (ms)
  #deprecated
  keepaliveInterval = 3000

  #deprecated
  clientReconnectWindow = 10000

  # how long the client waits after the keepaliveInterval before re-establishing
  # the connection (ms)
  #deprecated
  keepaliveReestablishDelay = 1000

  # how long the client waits for the connect handshake to complete before
  # retrying
  connectTimeout = 500

  # connection time to live - the maximum amount of time a persistent connection
  # is allowed to stay open before being re-established (ms)
  connectionTTL = 60000

  # total response size to pad out to in order to defeat intervening
  # bufferring by proxies (bytes)
  #deprecated
  flushBufferSize = 8096
}

//bounded-mailbox {
//  mailbox-type = "akka.dispatch.BoundedDequeBasedMailbox"
//  mailbox-capacity = 10
//  mailbox-push-timeout-time = -1 //10s
//}

processing-core-dispatcher {
  //  type = PinnedDispatcher
  //  executor = "thread-pool-executor"
  throughput = 2
  //  max-pool-size-min = 3
}

bdb-journal {
  //The directory to store the database environment
  dir = "journal"

  //true = Durability.COMMIT_SYNC, false = Durability.COMMIT_WRITE_NO_SYNC
  sync = true

  //size of the heap to use for the bdb cache
  cache-size-percent = 15

  //Number of threads used for journal compaction
  cleaner-threads = 2

  //Log usage stats to journal directory
  stats-collect = false
}

kamon {
  metrics {
    filters = [
      {
        actor {
          includes = ["*"]
          excludes = []
        }
      },
      {
        trace {
          includes = ["*"]
          excludes = []
        }
      }
    ]
  }

  statsd {
    # Hostname and port in which your StatsD is running. Remember that StatsD packets are sent using UDP and
    # setting unreachable hosts and/or not open ports wont be warned by the Kamon, your data wont go anywhere.
    hostname = "192.168.115.241"
    port = 8125

    # Interval between metrics data flushes to StatsD. It's value must be equal or greater than the
    # kamon.metrics.tick-interval setting.
    flush-interval = 1 second

    # Max packet size for UDP metrics data sent to StatsD.
    max-packet-size = 1024

    # Subscription patterns used to select which metrics will be pushed to StatsD. Note that first, metrics
    # collection for your desired entities must be activated under the kamon.metrics.filters settings.
    includes {
      actor = ["*"]
      trace = ["*"]
      dispatcher = ["*"]
      router = ["*"]
    }

    report-system-metrics = true

    simple-metric-key-generator {
      # Application prefix for all metrics pushed to StatsD. The default namespacing scheme for metrics follows
      # this pattern:
      #    application.host.entity.entity-name.metric-name
      application = "dm-processing"
    }
  }
}

dm-processing {
  templates {
    exampleRecordCount = 10
    checkForPublishEvery = 120s
    countNewStageTemplatesToSnapshot = 5000
    internalOperationsTimeout = 600s

    persistenceConfig {
      enabledJournaling = false
      enabledSnapshots = false
    }

  }

  translit {
    persistenceConfig {
      enabledJournaling = false
      enabledSnapshots = false
    }
  }

  writer {
    quotedFields = false
    deleteBeforeInsert = true
    packBufferSize = 10000
    writersCountPerTable = 10
  }

  dictionary {
    loadAllDictionaries = true
    exampleRecordCount = 5
    checkForPublishEveryNSec = 120
    countNewStageWordsToSnapshot = 10000

    persistenceConfig {
      enabledJournaling = false
      enabledSnapshots = false
    }
  }

  processor {
    logInfoIntervalMsg = 100000
    dictionaryFlushIntervalMsg = 200000
    templatesFlushIntervalMsg = 200000
  }

  dbcoordinator {
    maxDataQueueSize = 12

    persistenceConfig {
      enabledJournaling = true
      enabledSnapshots = false
    }
  }


  reader {
    batchSize = 50000
    //    shortTimeoutToSend = 4s
  }

  actors {
    pathToFullSave = backups/actors-full
    pathToShortSave = backups/actors-short
    pathToExport = backups/actors-export

    snapshotEvery = 10m
    fullSaveToFileEvery = 1h
    shortSaveToFileEvery = 10m
  }
}

topology {
  node-id = 1
  seq-cash = 20
}

test {
  InMainMenuPanelVisible = true
  UserDI = 15.1
}

mfms {
  ResultListJSFile = /javascript/IncludeModules
  ModulesLoadOrderFile = /javascript/ModulesLoadOrder
}

config {
  tailToEndRow = 1
  dataPageSize = 100
  drawAheadRatio = 1.6
}

dbPool {
  default = oracleMFMS
  defaultProd = oracleMFMSProd
  defaultSave = oracleMFMSSave
  defaultConfig = oracleMFMSConfig
}

bonecp-config-stack {

  bonecp-config-oracleMFMS {
    // Set host for Oracle connection
    driverClass = oracle.jdbc.OracleDriver

    //    host = 10.34.0.5
    //    serviceName = mstat
    //    username = DMPROD_SAVE
    //    password = ktd_njkcnjq

    host = orapg.simplesys.lan
    serviceName = test
    username = mosk
    password = m125osk

    // Set port for Oracle connection
    port = 1521

    //  Sets the name of the pool for JMX and thread names.
    poolName = oracleMFMS

    fetchSize = 1000

    //  Sets the minimum number of connections that will be contained in every partition.
    minConnectionsPerPartition = 5

    //  Sets the maximum number of connections that will be contained in every partition.
    //  Setting this to 5 with 3 partitions means you will have 15 unique
    // connections to the database. Note that the connection pool will not create all
    // these connections in one go but rather start off with minConnectionsPerPartition and gradually
    // increase connections as required.
    maxConnectionsPerPartition = 50

    //  Sets the acquireIncrement property.  When the available connections are about to run
    //  out, BoneCP will dynamically create new ones in batches. This property controls how
    //  many new connections to create in one go (up to a maximum of
    //  maxConnectionsPerPartition). Note: This is a per partition setting.
    acquireIncrement = 2

    //  Sets number of partitions to use.  In order to reduce lock contention
    //  and thus improve performance, each incoming connection request picks off a connection from
    //  a pool that has thread-affinity, i.e. pool[threadId % partition_count]. The higher this number,
    // the better your performance will be for the case when you have plenty
    // of short-lived threads. Beyond a certain threshold, maintenance of these pools will start
    // to have a negative effect on performance (and only for the case when
    // connections on a partition start running out).  Default: 1, minimum: 1, recommended:
    // 2-4 (but very app specific)
    partitionCount = 2

    //  Sets the JDBC connection URL.
    //jdbcUrl =


    //  Sets the idleConnectionTestPeriod.  This sets the time (in minutes), for a connection
    //    to remain idle before sending a test query to the DB. This is
    //    useful to prevent a DB from timing out connections on its end. Do
    //    not use aggressive values here!   Default: 240 min, set to 0
    //    to disable
    idleConnectionTestPeriodInMinutes = 10

    //  Sets the idleConnectionTestPeriod.  This sets the time (in seconds), for a connection
    //    to remain idle before sending a test query to the DB. This is
    //    useful to prevent a DB from timing out connections on its end. Do
    //    not use aggressive values here!   Default: 240 min, set to 0
    //    to disable
    idleConnectionTestPeriodInSeconds = 600

    //  Sets Idle max age (in min).  The time (in minutes), for a
    //connection to remain unused before it is closed off. Do not use aggressive
    //values here!  Default: 60 minutes, set to 0 to disable.
    idleMaxAgeInMinutes = 20

    //  Sets Idle max age (in seconds).  The time (in seconds), for a
    //connection to remain unused before it is closed off. Do not use aggressive
    //values here!  Default: 60 minutes, set to 0 to disable.
    idleMaxAgeInSeconds = 1200

    //  Sets the connection test statement.  The query to send to the DB
    //to maintain keep-alives and test for dead connections. This is database specific and
    //should be set to a query that consumes the minimal amount of load
    //on the server. Examples: MySQL: /* ping *\/ SELECT 1, PostgreSQL: SELECT NOW().
    //If you do not set this, then BoneCP will issue a metadata request
    //instead that should work on all databases but is probably slower.  (Note:
    //In MySQL, prefixing the statement by /* ping *\/ makes the driver issue
    //1 fast packet instead. See http://blogs.sun.com/SDNChannel/entry/mysql_tips_for_java_developers ) Default: Use metadata request
    //connectionTestStatement =

    //  Sets statementsCacheSize setting.  The number of statements to cache.
    statementsCacheSize = 0

    //  Sets number of helper threads to create that will handle releasing a connection.
    //When this value is set to zero, the application thread is blocked
    //until the pool is able to perform all the necessary cleanup to recycle
    //the connection and make it available for another thread.  When a non-zero
    //value is set, the pool will create threads that will take care of
    //recycling a connection when it is closed (the application dumps the connection into
    //a temporary queue to be processed asychronously to the application via the release
    //helper threads).  Useful when your application is doing lots of work on
    //each connection (i.e. perform an SQL query, do lots of non-DB stuff and
    //perform another query), otherwise will probably slow things down.
    releaseHelperThreads = 3

    //  Sets the connection hook.  Fully qualified class name that implements the ConnectionHook
    //interface (or extends AbstractConnectionHook). BoneCP will callback the specified class according to the
    //connection state (onAcquire, onCheckIn, onCheckout, onDestroy).
    // connectionHook =

    //  Specifies an initial SQL statement that is run only when a connection is
    //  first created.
    //  initSQL =

    //  Instruct the pool to create a helper thread to watch over connection acquires
    //that are never released (or released twice). This is for debugging purposes only
    //and will create a new thread for each call to getConnection(). Enabling this
    //option will have a big negative impact on pool performance.
    closeConnectionWatch = false

    //  If enabled, log SQL statements being executed.
    logStatementsEnabled = false

    //  Sets the number of ms to wait before attempting to obtain a connection
    // again after a failure.
    acquireRetryDelayInMs = 7000

    //  Set to true to force the connection pool to obtain the initial connections
    // lazily.
    lazyInit = false

    //  Set to true to enable recording of all transaction activity and replay the
    //  transaction automatically in case of a connection failure.
    transactionRecoveryEnabled = false

    //  After attempting to acquire a connection and failing, try to connect these many
    //  times before giving up. Default 5.
    acquireRetryAttempts = 5

    //  Sets the connection hook class name. Consider using setConnectionHook() instead.
    //  connectionHookClassName =

    //  Set to true to disable JMX.
    disableJMX = false

    //  If set, use datasourceBean.getConnection() to obtain a new connection instead of Driver.getConnection().
    //  datasourceBean =

    //  Queries taking longer than this limit to execute are logged.
    queryExecuteTimeLimitInMs = 0

    //  Sets the Pool Watch thread threshold.  The pool watch thread attempts to
    //maintain a number of connections always available (between minConnections and maxConnections). This value
    //sets the percentage value to maintain. For example, setting it to 20 means
    //that if the following condition holds: Free Connections / MaxConnections < poolAvailabilityThreshold
    //new connections will be created. In other words, it tries to keep at
    //least 20% of the pool full of connections. Setting the value to zero
    //will make the pool create new connections when it needs them but it
    //also means your application may have to wait for new connections to be
    //obtained at times.  Default: 20.
    poolAvailabilityThreshold = 20

    //  If set to true, the pool will not monitor connections for proper closure.
    //Enable this option if you only ever obtain your connections via a mechanism
    //that is guaranteed to release the connection back to the pool (eg Spring's
    //jdbcTemplate, some kind of transaction manager, etc).
    disableConnectionTracking = false

    //  Sets the maximum time (in milliseconds) to wait before a call to getConnection
    //is timed out.  Setting this to zero is similar to setting it
    //to Long.MAX_VALUE  Default: 0 ( = wait forever )
    connectionTimeoutInMs = 20000

    //  Sets the no of ms to wait when close connection watch threads are
    //  enabled. 0 = wait forever.
    closeConnectionWatchTimeoutInMs = 0

    //  Sets number of statement helper threads to create that will handle releasing a
    //statement.  When this value is set to zero, the application thread is
    //blocked until the pool and JDBC driver are able to close off the
    //statement.  When a non-zero value is set, the pool will create threads
    //that will take care of closing off the statement asychronously to the application
    //via the release helper threads).  Useful when your application is opening up
    //lots of statements otherwise will probably slow things down.
    statementReleaseHelperThreads = 2

    //  Sets the maxConnectionAge in seconds. Any connections older than this setting will be
    //closed off whether it is idle or not. Connections currently in use will
    //not be affected until they are returned to the pool.
    maxConnectionAgeInSeconds = 1200

    //  Sets the configFile. If configured, this will cause the pool to initialise using
    //  the config file in the same way as if calling new BoneCPConfig(filename).
    //  configFile =

    //  Sets the queue serviceOrder. Values currently understood are FIFO and LIFO.
    //  serviceOrder =

    //  If set to true, keep track of some more statistics for exposure via
    //  JMX. Will slow down the pool operation.
    statisticsEnabled = true

    //  Sets the defaultAutoCommit setting for newly created connections. If not set, use driver
    //  default.
    //  defaultAutoCommit =

    //  Sets the defaultReadOnly setting for newly created connections. If not set, use driver
    //  default.
    //  defaultReadOnly =

    //  Sets the defaultCatalog setting for newly created connections. If not set, use driver
    //  default.
    //  defaultCatalog =

    //  Sets the defaultTransactionIsolation. Should be set to one of: NONE, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ
    //  or SERIALIZABLE. If not set, will use driver default.
    //  defaultTransactionIsolation =

    //  If set to true, no attempts at passing in a username/password will be
    //attempted when trying to obtain a raw (driver) connection. Useful for cases when
    //you already have another mechanism on authentication eg NTLM.
    externalAuth = false

    //  Sets the classloader to use to load JDBC driver and hooks (set to
    //  null to use default).
    // classLoader =
  }

  bonecp-config-oracleMFMSProd {
    // Set host for Oracle connection
    driverClass = oracle.jdbc.OracleDriver

    //    host = 10.34.0.5
    //    serviceName = mstat
    //    username = DMPROD_READ
    //    password = bdfy_nehutytd

    host = orapg.simplesys.lan
    serviceName = test
    username = mosk
    password = m125osk

    // Set port for Oracle connection
    port = 1521

    //  Sets the name of the pool for JMX and thread names.
    poolName = oracleMFMSProd

    fetchSize = 1000

    //  Sets the minimum number of connections that will be contained in every partition.
    minConnectionsPerPartition = 5

    //  Sets the maximum number of connections that will be contained in every partition.
    //  Setting this to 5 with 3 partitions means you will have 15 unique
    // connections to the database. Note that the connection pool will not create all
    // these connections in one go but rather start off with minConnectionsPerPartition and gradually
    // increase connections as required.
    maxConnectionsPerPartition = 50

    //  Sets the acquireIncrement property.  When the available connections are about to run
    //  out, BoneCP will dynamically create new ones in batches. This property controls how
    //  many new connections to create in one go (up to a maximum of
    //  maxConnectionsPerPartition). Note: This is a per partition setting.
    acquireIncrement = 2

    //  Sets number of partitions to use.  In order to reduce lock contention
    //  and thus improve performance, each incoming connection request picks off a connection from
    //  a pool that has thread-affinity, i.e. pool[threadId % partition_count]. The higher this number,
    // the better your performance will be for the case when you have plenty
    // of short-lived threads. Beyond a certain threshold, maintenance of these pools will start
    // to have a negative effect on performance (and only for the case when
    // connections on a partition start running out).  Default: 1, minimum: 1, recommended:
    // 2-4 (but very app specific)
    partitionCount = 2

    //  Sets the JDBC connection URL.
    //jdbcUrl =


    //  Sets the idleConnectionTestPeriod.  This sets the time (in minutes), for a connection
    //    to remain idle before sending a test query to the DB. This is
    //    useful to prevent a DB from timing out connections on its end. Do
    //    not use aggressive values here!   Default: 240 min, set to 0
    //    to disable
    idleConnectionTestPeriodInMinutes = 10

    //  Sets the idleConnectionTestPeriod.  This sets the time (in seconds), for a connection
    //    to remain idle before sending a test query to the DB. This is
    //    useful to prevent a DB from timing out connections on its end. Do
    //    not use aggressive values here!   Default: 240 min, set to 0
    //    to disable
    idleConnectionTestPeriodInSeconds = 600

    //  Sets Idle max age (in min).  The time (in minutes), for a
    //connection to remain unused before it is closed off. Do not use aggressive
    //values here!  Default: 60 minutes, set to 0 to disable.
    idleMaxAgeInMinutes = 20

    //  Sets Idle max age (in seconds).  The time (in seconds), for a
    //connection to remain unused before it is closed off. Do not use aggressive
    //values here!  Default: 60 minutes, set to 0 to disable.
    idleMaxAgeInSeconds = 1200

    //  Sets the connection test statement.  The query to send to the DB
    //to maintain keep-alives and test for dead connections. This is database specific and
    //should be set to a query that consumes the minimal amount of load
    //on the server. Examples: MySQL: /* ping *\/ SELECT 1, PostgreSQL: SELECT NOW().
    //If you do not set this, then BoneCP will issue a metadata request
    //instead that should work on all databases but is probably slower.  (Note:
    //In MySQL, prefixing the statement by /* ping *\/ makes the driver issue
    //1 fast packet instead. See http://blogs.sun.com/SDNChannel/entry/mysql_tips_for_java_developers ) Default: Use metadata request
    //connectionTestStatement =

    //  Sets statementsCacheSize setting.  The number of statements to cache.
    statementsCacheSize = 0

    //  Sets number of helper threads to create that will handle releasing a connection.
    //When this value is set to zero, the application thread is blocked
    //until the pool is able to perform all the necessary cleanup to recycle
    //the connection and make it available for another thread.  When a non-zero
    //value is set, the pool will create threads that will take care of
    //recycling a connection when it is closed (the application dumps the connection into
    //a temporary queue to be processed asychronously to the application via the release
    //helper threads).  Useful when your application is doing lots of work on
    //each connection (i.e. perform an SQL query, do lots of non-DB stuff and
    //perform another query), otherwise will probably slow things down.
    releaseHelperThreads = 3

    //  Sets the connection hook.  Fully qualified class name that implements the ConnectionHook
    //interface (or extends AbstractConnectionHook). BoneCP will callback the specified class according to the
    //connection state (onAcquire, onCheckIn, onCheckout, onDestroy).
    // connectionHook =

    //  Specifies an initial SQL statement that is run only when a connection is
    //  first created.
    //  initSQL =

    //  Instruct the pool to create a helper thread to watch over connection acquires
    //that are never released (or released twice). This is for debugging purposes only
    //and will create a new thread for each call to getConnection(). Enabling this
    //option will have a big negative impact on pool performance.
    closeConnectionWatch = false

    //  If enabled, log SQL statements being executed.
    logStatementsEnabled = false

    //  Sets the number of ms to wait before attempting to obtain a connection
    // again after a failure.
    acquireRetryDelayInMs = 7000

    //  Set to true to force the connection pool to obtain the initial connections
    // lazily.
    lazyInit = false

    //  Set to true to enable recording of all transaction activity and replay the
    //  transaction automatically in case of a connection failure.
    transactionRecoveryEnabled = false

    //  After attempting to acquire a connection and failing, try to connect these many
    //  times before giving up. Default 5.
    acquireRetryAttempts = 5

    //  Sets the connection hook class name. Consider using setConnectionHook() instead.
    //  connectionHookClassName =

    //  Set to true to disable JMX.
    disableJMX = false

    //  If set, use datasourceBean.getConnection() to obtain a new connection instead of Driver.getConnection().
    //  datasourceBean =

    //  Queries taking longer than this limit to execute are logged.
    queryExecuteTimeLimitInMs = 0

    //  Sets the Pool Watch thread threshold.  The pool watch thread attempts to
    //maintain a number of connections always available (between minConnections and maxConnections). This value
    //sets the percentage value to maintain. For example, setting it to 20 means
    //that if the following condition holds: Free Connections / MaxConnections < poolAvailabilityThreshold
    //new connections will be created. In other words, it tries to keep at
    //least 20% of the pool full of connections. Setting the value to zero
    //will make the pool create new connections when it needs them but it
    //also means your application may have to wait for new connections to be
    //obtained at times.  Default: 20.
    poolAvailabilityThreshold = 20

    //  If set to true, the pool will not monitor connections for proper closure.
    //Enable this option if you only ever obtain your connections via a mechanism
    //that is guaranteed to release the connection back to the pool (eg Spring's
    //jdbcTemplate, some kind of transaction manager, etc).
    disableConnectionTracking = false

    //  Sets the maximum time (in milliseconds) to wait before a call to getConnection
    //is timed out.  Setting this to zero is similar to setting it
    //to Long.MAX_VALUE  Default: 0 ( = wait forever )
    connectionTimeoutInMs = 20000

    //  Sets the no of ms to wait when close connection watch threads are
    //  enabled. 0 = wait forever.
    closeConnectionWatchTimeoutInMs = 0

    //  Sets number of statement helper threads to create that will handle releasing a
    //statement.  When this value is set to zero, the application thread is
    //blocked until the pool and JDBC driver are able to close off the
    //statement.  When a non-zero value is set, the pool will create threads
    //that will take care of closing off the statement asychronously to the application
    //via the release helper threads).  Useful when your application is opening up
    //lots of statements otherwise will probably slow things down.
    statementReleaseHelperThreads = 2

    //  Sets the maxConnectionAge in seconds. Any connections older than this setting will be
    //closed off whether it is idle or not. Connections currently in use will
    //not be affected until they are returned to the pool.
    maxConnectionAgeInSeconds = 1200

    //  Sets the configFile. If configured, this will cause the pool to initialise using
    //  the config file in the same way as if calling new BoneCPConfig(filename).
    //  configFile =

    //  Sets the queue serviceOrder. Values currently understood are FIFO and LIFO.
    //  serviceOrder =

    //  If set to true, keep track of some more statistics for exposure via
    //  JMX. Will slow down the pool operation.
    statisticsEnabled = true

    //  Sets the defaultAutoCommit setting for newly created connections. If not set, use driver
    //  default.
    //  defaultAutoCommit =

    //  Sets the defaultReadOnly setting for newly created connections. If not set, use driver
    //  default.
    //  defaultReadOnly =

    //  Sets the defaultCatalog setting for newly created connections. If not set, use driver
    //  default.
    //  defaultCatalog =

    //  Sets the defaultTransactionIsolation. Should be set to one of: NONE, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ
    //  or SERIALIZABLE. If not set, will use driver default.
    //  defaultTransactionIsolation =

    //  If set to true, no attempts at passing in a username/password will be
    //attempted when trying to obtain a raw (driver) connection. Useful for cases when
    //you already have another mechanism on authentication eg NTLM.
    externalAuth = false

    //  Sets the classloader to use to load JDBC driver and hooks (set to
    //  null to use default).
    // classLoader =
  }

  bonecp-config-oracleMFMSSave {
    // Set host for Oracle connection
    driverClass = oracle.jdbc.OracleDriver

    //    host = 10.34.0.5
    //    serviceName = mstat
    //    username = DMPROD_SAVE
    //    password = ktd_njkcnjq

    host = orapg.simplesys.lan
    serviceName = test
    username = mosk
    password = m125osk

    // Set port for Oracle connection
    port = 1521

    //  Sets the name of the pool for JMX and thread names.
    poolName = oracleMFMSSave

    fetchSize = 1000

    //  Sets the minimum number of connections that will be contained in every partition.
    minConnectionsPerPartition = 5

    //  Sets the maximum number of connections that will be contained in every partition.
    //  Setting this to 5 with 3 partitions means you will have 15 unique
    // connections to the database. Note that the connection pool will not create all
    // these connections in one go but rather start off with minConnectionsPerPartition and gradually
    // increase connections as required.
    maxConnectionsPerPartition = 50

    //  Sets the acquireIncrement property.  When the available connections are about to run
    //  out, BoneCP will dynamically create new ones in batches. This property controls how
    //  many new connections to create in one go (up to a maximum of
    //  maxConnectionsPerPartition). Note: This is a per partition setting.
    acquireIncrement = 2

    //  Sets number of partitions to use.  In order to reduce lock contention
    //  and thus improve performance, each incoming connection request picks off a connection from
    //  a pool that has thread-affinity, i.e. pool[threadId % partition_count]. The higher this number,
    // the better your performance will be for the case when you have plenty
    // of short-lived threads. Beyond a certain threshold, maintenance of these pools will start
    // to have a negative effect on performance (and only for the case when
    // connections on a partition start running out).  Default: 1, minimum: 1, recommended:
    // 2-4 (but very app specific)
    partitionCount = 2

    //  Sets the JDBC connection URL.
    //jdbcUrl =


    //  Sets the idleConnectionTestPeriod.  This sets the time (in minutes), for a connection
    //    to remain idle before sending a test query to the DB. This is
    //    useful to prevent a DB from timing out connections on its end. Do
    //    not use aggressive values here!   Default: 240 min, set to 0
    //    to disable
    idleConnectionTestPeriodInMinutes = 10

    //  Sets the idleConnectionTestPeriod.  This sets the time (in seconds), for a connection
    //    to remain idle before sending a test query to the DB. This is
    //    useful to prevent a DB from timing out connections on its end. Do
    //    not use aggressive values here!   Default: 240 min, set to 0
    //    to disable
    idleConnectionTestPeriodInSeconds = 600

    //  Sets Idle max age (in min).  The time (in minutes), for a
    //connection to remain unused before it is closed off. Do not use aggressive
    //values here!  Default: 60 minutes, set to 0 to disable.
    idleMaxAgeInMinutes = 20

    //  Sets Idle max age (in seconds).  The time (in seconds), for a
    //connection to remain unused before it is closed off. Do not use aggressive
    //values here!  Default: 60 minutes, set to 0 to disable.
    idleMaxAgeInSeconds = 1200

    //  Sets the connection test statement.  The query to send to the DB
    //to maintain keep-alives and test for dead connections. This is database specific and
    //should be set to a query that consumes the minimal amount of load
    //on the server. Examples: MySQL: /* ping *\/ SELECT 1, PostgreSQL: SELECT NOW().
    //If you do not set this, then BoneCP will issue a metadata request
    //instead that should work on all databases but is probably slower.  (Note:
    //In MySQL, prefixing the statement by /* ping *\/ makes the driver issue
    //1 fast packet instead. See http://blogs.sun.com/SDNChannel/entry/mysql_tips_for_java_developers ) Default: Use metadata request
    //connectionTestStatement =

    //  Sets statementsCacheSize setting.  The number of statements to cache.
    statementsCacheSize = 0

    //  Sets number of helper threads to create that will handle releasing a connection.
    //When this value is set to zero, the application thread is blocked
    //until the pool is able to perform all the necessary cleanup to recycle
    //the connection and make it available for another thread.  When a non-zero
    //value is set, the pool will create threads that will take care of
    //recycling a connection when it is closed (the application dumps the connection into
    //a temporary queue to be processed asychronously to the application via the release
    //helper threads).  Useful when your application is doing lots of work on
    //each connection (i.e. perform an SQL query, do lots of non-DB stuff and
    //perform another query), otherwise will probably slow things down.
    releaseHelperThreads = 3

    //  Sets the connection hook.  Fully qualified class name that implements the ConnectionHook
    //interface (or extends AbstractConnectionHook). BoneCP will callback the specified class according to the
    //connection state (onAcquire, onCheckIn, onCheckout, onDestroy).
    // connectionHook =

    //  Specifies an initial SQL statement that is run only when a connection is
    //  first created.
    //  initSQL =

    //  Instruct the pool to create a helper thread to watch over connection acquires
    //that are never released (or released twice). This is for debugging purposes only
    //and will create a new thread for each call to getConnection(). Enabling this
    //option will have a big negative impact on pool performance.
    closeConnectionWatch = false

    //  If enabled, log SQL statements being executed.
    logStatementsEnabled = false

    //  Sets the number of ms to wait before attempting to obtain a connection
    // again after a failure.
    acquireRetryDelayInMs = 7000

    //  Set to true to force the connection pool to obtain the initial connections
    // lazily.
    lazyInit = false

    //  Set to true to enable recording of all transaction activity and replay the
    //  transaction automatically in case of a connection failure.
    transactionRecoveryEnabled = false

    //  After attempting to acquire a connection and failing, try to connect these many
    //  times before giving up. Default 5.
    acquireRetryAttempts = 5

    //  Sets the connection hook class name. Consider using setConnectionHook() instead.
    //  connectionHookClassName =

    //  Set to true to disable JMX.
    disableJMX = false

    //  If set, use datasourceBean.getConnection() to obtain a new connection instead of Driver.getConnection().
    //  datasourceBean =

    //  Queries taking longer than this limit to execute are logged.
    queryExecuteTimeLimitInMs = 0

    //  Sets the Pool Watch thread threshold.  The pool watch thread attempts to
    //maintain a number of connections always available (between minConnections and maxConnections). This value
    //sets the percentage value to maintain. For example, setting it to 20 means
    //that if the following condition holds: Free Connections / MaxConnections < poolAvailabilityThreshold
    //new connections will be created. In other words, it tries to keep at
    //least 20% of the pool full of connections. Setting the value to zero
    //will make the pool create new connections when it needs them but it
    //also means your application may have to wait for new connections to be
    //obtained at times.  Default: 20.
    poolAvailabilityThreshold = 20

    //  If set to true, the pool will not monitor connections for proper closure.
    //Enable this option if you only ever obtain your connections via a mechanism
    //that is guaranteed to release the connection back to the pool (eg Spring's
    //jdbcTemplate, some kind of transaction manager, etc).
    disableConnectionTracking = false

    //  Sets the maximum time (in milliseconds) to wait before a call to getConnection
    //is timed out.  Setting this to zero is similar to setting it
    //to Long.MAX_VALUE  Default: 0 ( = wait forever )
    connectionTimeoutInMs = 20000

    //  Sets the no of ms to wait when close connection watch threads are
    //  enabled. 0 = wait forever.
    closeConnectionWatchTimeoutInMs = 0

    //  Sets number of statement helper threads to create that will handle releasing a
    //statement.  When this value is set to zero, the application thread is
    //blocked until the pool and JDBC driver are able to close off the
    //statement.  When a non-zero value is set, the pool will create threads
    //that will take care of closing off the statement asychronously to the application
    //via the release helper threads).  Useful when your application is opening up
    //lots of statements otherwise will probably slow things down.
    statementReleaseHelperThreads = 2

    //  Sets the maxConnectionAge in seconds. Any connections older than this setting will be
    //closed off whether it is idle or not. Connections currently in use will
    //not be affected until they are returned to the pool.
    maxConnectionAgeInSeconds = 1200

    //  Sets the configFile. If configured, this will cause the pool to initialise using
    //  the config file in the same way as if calling new BoneCPConfig(filename).
    //  configFile =

    //  Sets the queue serviceOrder. Values currently understood are FIFO and LIFO.
    //  serviceOrder =

    //  If set to true, keep track of some more statistics for exposure via
    //  JMX. Will slow down the pool operation.
    statisticsEnabled = true

    //  Sets the defaultAutoCommit setting for newly created connections. If not set, use driver
    //  default.
    //  defaultAutoCommit =

    //  Sets the defaultReadOnly setting for newly created connections. If not set, use driver
    //  default.
    //  defaultReadOnly =

    //  Sets the defaultCatalog setting for newly created connections. If not set, use driver
    //  default.
    //  defaultCatalog =

    //  Sets the defaultTransactionIsolation. Should be set to one of: NONE, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ
    //  or SERIALIZABLE. If not set, will use driver default.
    //  defaultTransactionIsolation =

    //  If set to true, no attempts at passing in a username/password will be
    //attempted when trying to obtain a raw (driver) connection. Useful for cases when
    //you already have another mechanism on authentication eg NTLM.
    externalAuth = false

    //  Sets the classloader to use to load JDBC driver and hooks (set to
    //  null to use default).
    // classLoader =
  }

  bonecp-config-oracleMFMSConfig {
      // Set host for Oracle connection
      driverClass = oracle.jdbc.OracleDriver

      //    host = 10.34.0.5
      //    serviceName = mstat
      //    username = DMPROD_SAVE
      //    password = ktd_njkcnjq

      host = orapg.simplesys.lan
      serviceName = test
      username = mosk
      password = m125osk

      // Set port for Oracle connection
      port = 1521

      //  Sets the name of the pool for JMX and thread names.
      poolName = oracleMFMSConfig

      fetchSize = 1000

      //  Sets the minimum number of connections that will be contained in every partition.
      minConnectionsPerPartition = 5

      //  Sets the maximum number of connections that will be contained in every partition.
      //  Setting this to 5 with 3 partitions means you will have 15 unique
      // connections to the database. Note that the connection pool will not create all
      // these connections in one go but rather start off with minConnectionsPerPartition and gradually
      // increase connections as required.
      maxConnectionsPerPartition = 50

      //  Sets the acquireIncrement property.  When the available connections are about to run
      //  out, BoneCP will dynamically create new ones in batches. This property controls how
      //  many new connections to create in one go (up to a maximum of
      //  maxConnectionsPerPartition). Note: This is a per partition setting.
      acquireIncrement = 2

      //  Sets number of partitions to use.  In order to reduce lock contention
      //  and thus improve performance, each incoming connection request picks off a connection from
      //  a pool that has thread-affinity, i.e. pool[threadId % partition_count]. The higher this number,
      // the better your performance will be for the case when you have plenty
      // of short-lived threads. Beyond a certain threshold, maintenance of these pools will start
      // to have a negative effect on performance (and only for the case when
      // connections on a partition start running out).  Default: 1, minimum: 1, recommended:
      // 2-4 (but very app specific)
      partitionCount = 2

      //  Sets the JDBC connection URL.
      //jdbcUrl =


      //  Sets the idleConnectionTestPeriod.  This sets the time (in minutes), for a connection
      //    to remain idle before sending a test query to the DB. This is
      //    useful to prevent a DB from timing out connections on its end. Do
      //    not use aggressive values here!   Default: 240 min, set to 0
      //    to disable
      idleConnectionTestPeriodInMinutes = 10

      //  Sets the idleConnectionTestPeriod.  This sets the time (in seconds), for a connection
      //    to remain idle before sending a test query to the DB. This is
      //    useful to prevent a DB from timing out connections on its end. Do
      //    not use aggressive values here!   Default: 240 min, set to 0
      //    to disable
      idleConnectionTestPeriodInSeconds = 600

      //  Sets Idle max age (in min).  The time (in minutes), for a
      //connection to remain unused before it is closed off. Do not use aggressive
      //values here!  Default: 60 minutes, set to 0 to disable.
      idleMaxAgeInMinutes = 20

      //  Sets Idle max age (in seconds).  The time (in seconds), for a
      //connection to remain unused before it is closed off. Do not use aggressive
      //values here!  Default: 60 minutes, set to 0 to disable.
      idleMaxAgeInSeconds = 1200

      //  Sets the connection test statement.  The query to send to the DB
      //to maintain keep-alives and test for dead connections. This is database specific and
      //should be set to a query that consumes the minimal amount of load
      //on the server. Examples: MySQL: /* ping *\/ SELECT 1, PostgreSQL: SELECT NOW().
      //If you do not set this, then BoneCP will issue a metadata request
      //instead that should work on all databases but is probably slower.  (Note:
      //In MySQL, prefixing the statement by /* ping *\/ makes the driver issue
      //1 fast packet instead. See http://blogs.sun.com/SDNChannel/entry/mysql_tips_for_java_developers ) Default: Use metadata request
      //connectionTestStatement =

      //  Sets statementsCacheSize setting.  The number of statements to cache.
      statementsCacheSize = 0

      //  Sets number of helper threads to create that will handle releasing a connection.
      //When this value is set to zero, the application thread is blocked
      //until the pool is able to perform all the necessary cleanup to recycle
      //the connection and make it available for another thread.  When a non-zero
      //value is set, the pool will create threads that will take care of
      //recycling a connection when it is closed (the application dumps the connection into
      //a temporary queue to be processed asychronously to the application via the release
      //helper threads).  Useful when your application is doing lots of work on
      //each connection (i.e. perform an SQL query, do lots of non-DB stuff and
      //perform another query), otherwise will probably slow things down.
      releaseHelperThreads = 3

      //  Sets the connection hook.  Fully qualified class name that implements the ConnectionHook
      //interface (or extends AbstractConnectionHook). BoneCP will callback the specified class according to the
      //connection state (onAcquire, onCheckIn, onCheckout, onDestroy).
      // connectionHook =

      //  Specifies an initial SQL statement that is run only when a connection is
      //  first created.
      //  initSQL =

      //  Instruct the pool to create a helper thread to watch over connection acquires
      //that are never released (or released twice). This is for debugging purposes only
      //and will create a new thread for each call to getConnection(). Enabling this
      //option will have a big negative impact on pool performance.
      closeConnectionWatch = false

      //  If enabled, log SQL statements being executed.
      logStatementsEnabled = false

      //  Sets the number of ms to wait before attempting to obtain a connection
      // again after a failure.
      acquireRetryDelayInMs = 7000

      //  Set to true to force the connection pool to obtain the initial connections
      // lazily.
      lazyInit = false

      //  Set to true to enable recording of all transaction activity and replay the
      //  transaction automatically in case of a connection failure.
      transactionRecoveryEnabled = false

      //  After attempting to acquire a connection and failing, try to connect these many
      //  times before giving up. Default 5.
      acquireRetryAttempts = 5

      //  Sets the connection hook class name. Consider using setConnectionHook() instead.
      //  connectionHookClassName =

      //  Set to true to disable JMX.
      disableJMX = false

      //  If set, use datasourceBean.getConnection() to obtain a new connection instead of Driver.getConnection().
      //  datasourceBean =

      //  Queries taking longer than this limit to execute are logged.
      queryExecuteTimeLimitInMs = 0

      //  Sets the Pool Watch thread threshold.  The pool watch thread attempts to
      //maintain a number of connections always available (between minConnections and maxConnections). This value
      //sets the percentage value to maintain. For example, setting it to 20 means
      //that if the following condition holds: Free Connections / MaxConnections < poolAvailabilityThreshold
      //new connections will be created. In other words, it tries to keep at
      //least 20% of the pool full of connections. Setting the value to zero
      //will make the pool create new connections when it needs them but it
      //also means your application may have to wait for new connections to be
      //obtained at times.  Default: 20.
      poolAvailabilityThreshold = 20

      //  If set to true, the pool will not monitor connections for proper closure.
      //Enable this option if you only ever obtain your connections via a mechanism
      //that is guaranteed to release the connection back to the pool (eg Spring's
      //jdbcTemplate, some kind of transaction manager, etc).
      disableConnectionTracking = false

      //  Sets the maximum time (in milliseconds) to wait before a call to getConnection
      //is timed out.  Setting this to zero is similar to setting it
      //to Long.MAX_VALUE  Default: 0 ( = wait forever )
      connectionTimeoutInMs = 20000

      //  Sets the no of ms to wait when close connection watch threads are
      //  enabled. 0 = wait forever.
      closeConnectionWatchTimeoutInMs = 0

      //  Sets number of statement helper threads to create that will handle releasing a
      //statement.  When this value is set to zero, the application thread is
      //blocked until the pool and JDBC driver are able to close off the
      //statement.  When a non-zero value is set, the pool will create threads
      //that will take care of closing off the statement asychronously to the application
      //via the release helper threads).  Useful when your application is opening up
      //lots of statements otherwise will probably slow things down.
      statementReleaseHelperThreads = 2

      //  Sets the maxConnectionAge in seconds. Any connections older than this setting will be
      //closed off whether it is idle or not. Connections currently in use will
      //not be affected until they are returned to the pool.
      maxConnectionAgeInSeconds = 1200

      //  Sets the configFile. If configured, this will cause the pool to initialise using
      //  the config file in the same way as if calling new BoneCPConfig(filename).
      //  configFile =

      //  Sets the queue serviceOrder. Values currently understood are FIFO and LIFO.
      //  serviceOrder =

      //  If set to true, keep track of some more statistics for exposure via
      //  JMX. Will slow down the pool operation.
      statisticsEnabled = true

      //  Sets the defaultAutoCommit setting for newly created connections. If not set, use driver
      //  default.
      //  defaultAutoCommit =

      //  Sets the defaultReadOnly setting for newly created connections. If not set, use driver
      //  default.
      //  defaultReadOnly =

      //  Sets the defaultCatalog setting for newly created connections. If not set, use driver
      //  default.
      //  defaultCatalog =

      //  Sets the defaultTransactionIsolation. Should be set to one of: NONE, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ
      //  or SERIALIZABLE. If not set, will use driver default.
      //  defaultTransactionIsolation =

      //  If set to true, no attempts at passing in a username/password will be
      //attempted when trying to obtain a raw (driver) connection. Useful for cases when
      //you already have another mechanism on authentication eg NTLM.
      externalAuth = false

      //  Sets the classloader to use to load JDBC driver and hooks (set to
      //  null to use default).
      // classLoader =
    }
}
